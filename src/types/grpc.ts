"use strict";

import { RestateContext, setContext } from "../restate_context";
import { FileDescriptorProto } from "ts-proto-descriptors";
import {
  OutputStreamEntryMessage,
  SuspensionMessage,
} from "../generated/proto/protocol";
import { rlog } from "../utils/logger";
import { OUTPUT_STREAM_ENTRY_MESSAGE_TYPE } from "./protocol";
import { Message } from "./types";

export class GrpcServiceMethod<I, O> {
  constructor(
    readonly name: string, // the gRPC name as defined in the .proto file
    readonly localName: string, // the method name as defined in the class.
    readonly localFn: (instance: unknown, input: I) => Promise<O>, // the actual function
    readonly inputDecoder: (buf: Uint8Array) => I, // the protobuf decoder
    readonly outputEncoder: (output: O) => Uint8Array // protobuf encoder
  ) {}
}

export class GrpcService {
  constructor(
    readonly name: string,
    readonly packge: string,
    readonly impl: object,
    readonly methods: Array<GrpcServiceMethod<unknown, unknown>>
  ) {}
}

export class HostedGrpcServiceMethod<I, O> {
  // used to fail the invocation on an error
  /* eslint-disable @typescript-eslint/no-explicit-any */
  public reject!: (reason: any) => void;
  // used to resolve the invocation on suspensions (so when we have no output response yet)
  public resolve!: (value: Message | PromiseLike<Message>) => void;

  constructor(
    readonly instance: unknown,
    readonly packge: string,
    readonly service: string,
    readonly method: GrpcServiceMethod<I, O>
  ) {}

  // The end of an invoke is either a response (Uint8Array) or a SuspensionMessage
  async invoke(
    context: RestateContext,
    inBytes: Uint8Array,
    logPrefix: string
  ): Promise<Message> {
    return new Promise<Message>((resolve, reject) => {
      this.reject = reject;
      this.resolve = resolve;
      const instanceWithContext = setContext(this.instance, context);
      const input = this.method.inputDecoder(inBytes);
      rlog.debugJournalMessage(logPrefix, "Received input message.", input);
      this.method
        .localFn(instanceWithContext, input)
        .then((output) => {
          rlog.debug("Encoding the output message");
          const outBytes = this.method.outputEncoder(output);
          const msg = OutputStreamEntryMessage.create({
            value: Buffer.from(outBytes),
          });
          resolve(new Message(OUTPUT_STREAM_ENTRY_MESSAGE_TYPE, msg));
        })
        .catch((error) => {
          reject(error);
        });
    });
  }
}

//
// The following definitions are equivalent to the ones
// generated by the protoc ts plugin.
// we use them to traverse the FileDescriptor
//
/* eslint-disable @typescript-eslint/no-explicit-any */
type ProtoMetaMessageOptions = {
  options?: { [key: string]: any };
  fields?: { [key: string]: { [key: string]: any } };
  oneof?: { [key: string]: { [key: string]: any } };
  nested?: { [key: string]: ProtoMetaMessageOptions };
};

export interface ProtoMetadata {
  fileDescriptor: FileDescriptorProto;
  references: { [key: string]: any };
  dependencies?: ProtoMetadata[];
  options?: {
    options?: { [key: string]: any };
    services?: {
      [key: string]: {
        options?: { [key: string]: any };
        methods?: { [key: string]: { [key: string]: any } };
      };
    };
    messages?: { [key: string]: ProtoMetaMessageOptions };
    enums?: {
      [key: string]: {
        options?: { [key: string]: any };
        values?: { [key: string]: { [key: string]: any } };
      };
    };
  };
}
