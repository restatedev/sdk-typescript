/* eslint-disable @typescript-eslint/no-explicit-any */

import { FileDescriptorProto } from "ts-proto-descriptors";
import {
  AwakeableEntryMessage,
  BackgroundInvokeEntryMessage,
  ClearStateEntryMessage,
  CompleteAwakeableEntryMessage,
  CompletionMessage,
  GetStateEntryMessage,
  InvokeEntryMessage,
  OutputStreamEntryMessage,
  PollInputStreamEntryMessage,
  SetStateEntryMessage,
  SleepEntryMessage,
  StartMessage,
} from "./protocol_stream";
import { Failure } from "./generated/proto/protocol";

// Side effect message type for Typescript SDK
// Side effects are custom messages because the runtime does not need to inspect them
export const SIDE_EFFECT_ENTRY_MESSAGE_TYPE = 0xfc01n;

export class AwakeableIdentifier {
  constructor(
    readonly serviceName: string,
    readonly instanceKey: Buffer,
    readonly invocationId: Buffer,
    readonly entryIndex: number
  ) {}
}

export type ProtocolMessage =
  | StartMessage
  | CompletionMessage
  | PollInputStreamEntryMessage
  | OutputStreamEntryMessage
  | GetStateEntryMessage
  | SetStateEntryMessage
  | ClearStateEntryMessage
  | SleepEntryMessage
  | InvokeEntryMessage
  | BackgroundInvokeEntryMessage
  | AwakeableEntryMessage
  | CompleteAwakeableEntryMessage;

export class Message {
  constructor(
    readonly messageType: bigint,
    readonly message: ProtocolMessage | Uint8Array,
    readonly completed?: boolean,
    readonly requires_ack?: boolean
  ) {}
}

export class PromiseHandler {
  constructor(
    readonly resolve: (value: unknown) => void,
    readonly reject: (reason: Failure | Error) => void
  ) {}
}

export class SideEffectOutput<T> {
  constructor(readonly value?: T, readonly failure?: Failure) {}
}

export function printMessageAsJson(obj: any): string {
  const newObj = { ...(obj as Record<string, unknown>) };
  for (const [key, value] of Object.entries(newObj)) {
    if (Buffer.isBuffer(value)) {
      newObj[key] = JSON.stringify(value.toString());
    }
  }
  return JSON.stringify(newObj);
}

//
// The following definitions are equivalent to the ones
// generated by the protoc ts plugin.
// we use them to traverse the FileDescriptor
//

type ProtoMetaMessageOptions = {
  options?: { [key: string]: any };
  fields?: { [key: string]: { [key: string]: any } };
  oneof?: { [key: string]: { [key: string]: any } };
  nested?: { [key: string]: ProtoMetaMessageOptions };
};

export interface ProtoMetadata {
  fileDescriptor: FileDescriptorProto;
  references: { [key: string]: any };
  dependencies?: ProtoMetadata[];
  options?: {
    options?: { [key: string]: any };
    services?: {
      [key: string]: {
        options?: { [key: string]: any };
        methods?: { [key: string]: { [key: string]: any } };
      };
    };
    messages?: { [key: string]: ProtoMetaMessageOptions };
    enums?: {
      [key: string]: {
        options?: { [key: string]: any };
        values?: { [key: string]: { [key: string]: any } };
      };
    };
  };
}

//
// The following definitions capture the parsed gRPC service definition
//

export class GrpcServiceMethod<I, O> {
  constructor(
    readonly name: string, // the gRPC name as defined in the .proto file
    readonly localName: string, // the method name as defined in the class.
    readonly localFn: (instance: unknown, input: I) => Promise<O>, // the actual function
    readonly inputDecoder: (buf: Uint8Array) => I, // the protobuf decoder
    readonly outputEncoder: (output: O) => Uint8Array // protobuf encoder
  ) {}
}

export class GrpcService {
  constructor(
    readonly name: string,
    readonly packge: string,
    readonly impl: object,
    readonly methods: Array<GrpcServiceMethod<unknown, unknown>>
  ) {}
}

//
// Here comes black magic. Given:
// * an instance of a class that implements a gRPC TypeScript interface,
//   as generated by our protoc plugin, this method
// * The ProtobufFileDescriptor as generated by the protobuf plugin
// * and the gRPC service name
//
// Return a GrpcService definition, as defined above.
//
// For example (see first: example.proto and example.ts):
//
// > parse(example.protoMetaData, "Greeter", new GreeterService())
//
//  produces ~
//
//  serviceName: 'Greeter',
//  instance: GreeterService {},
//  methods: {
//    multiword: {
//     localName: 'multiWord',
//     fn: [Function: multiWord],
//     inputType: [Object],
//     outputType: [Object]
//    },
//    greet: {
//      localName: 'greet',
//      fn: [Function: greet],
//      inputType: [Object],
//      outputType: [Object]
//    }
//  }
//}
//
export function parseService(
  meta: ProtoMetadata,
  serviceName: string,
  instance: any
) {
  const svcMethods: Array<GrpcServiceMethod<unknown, unknown>> = [];

  // index all the existing properties that `instance` has.
  // we index them by the lower case represention.
  const prototype = Object.getPrototypeOf(instance);
  const names = new Map<string, string>(
    Object.getOwnPropertyNames(prototype).map((name) => [
      name.toLowerCase(),
      name,
    ])
  );

  for (const serviceDescriptor of meta.fileDescriptor.service) {
    if (serviceName !== serviceDescriptor.name) {
      continue;
    }
    for (const methodDescriptor of serviceDescriptor.method) {
      const lowercaseName = methodDescriptor.name.toLowerCase();
      const localName = names.get(lowercaseName);
      if (localName === undefined || localName === null) {
        throw new Error(`unimplemented method ${methodDescriptor.name}`);
      }
      const fn = instance[localName];
      if (typeof fn !== "function") {
        throw new Error(
          `A property ${localName} exists, which coresponds to a gRPC service named ${methodDescriptor.name}, but that property is not a function.`
        );
      }
      const localMethod = async (instance: unknown, input: unknown) => {
        return await fn.call(instance, input);
      };
      const inputMessage = meta.references[methodDescriptor.inputType];
      let outputMessage = meta.references[methodDescriptor.outputType];
      // If the output message type is not defined by use but by a dependency (e.g. BoolValue, Empty, etc)
      // then we need to look for the encoders and decoders in the dependencies.
      if (outputMessage === undefined) {
        meta.dependencies?.forEach((dep) => {
          if (dep.references[methodDescriptor.outputType] !== undefined) {
            outputMessage = dep.references[methodDescriptor.outputType];
          }
        });
      }

      const decoder = (buffer: Uint8Array) => inputMessage.decode(buffer);
      const encoder = (message: unknown) =>
        outputMessage.encode(message).finish();
      svcMethods.push(
        new GrpcServiceMethod<unknown, unknown>(
          methodDescriptor.name,
          localName,
          localMethod,
          decoder,
          encoder
        )
      );
    }
    return new GrpcService(
      serviceName,
      meta.fileDescriptor.package,
      instance,
      svcMethods
    );
  }
  throw new Error(`Unable to find a service ${serviceName}.`);
}
