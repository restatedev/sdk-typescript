"use strict";

import { rlog } from "../utils/logger";
import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda";
import {
  ProtocolMode,
  ServiceDiscoveryResponse,
} from "../generated/proto/discovery";
import { BaseRestateServer, ServiceOpts } from "./base_restate_server";
import { DurableExecutionStateMachine } from "../state_machine";
import { LambdaConnection } from "../connection/lambda_connection";

/**
 * Creates an Restate entrypoint for services deployed on AWS Lambda and invoked
 * through API Gateway.
 *
 * Register services on this entrypoint via {@link LambdaRestateServer.bindService } and
 * then create the Lambda invocation handler via {@link LambdaRestateServer.handle }.
 *
 * @example
 * A typical AWS Lambda entry point would look like this
 * ```
 * import * as restate from "@restatedev/restate-sdk";
 *
 * export const handler = restate
 *   .createLambdaApiGatewayHandler()
 *   .bindService({
 *      service: "MyService",
 *      instance: new myService.MyServiceImpl(),
 *      descriptor: myService.protoMetadata,
 *    })
 *   .handle();
 * ```
 */
export function createLambdaApiGatewayHandler(): LambdaRestateServer {
  return new LambdaRestateServer();
}

/**
 * Restate entrypoint implementation for services deployed on AWS Lambda.
 * This one decodes the requests, create the log event sequence that
 * drives the durable execution of the service invocations.
 */
export class LambdaRestateServer extends BaseRestateServer {
  constructor() {
    super(ProtocolMode.REQUEST_RESPONSE);
  }

  /**
   * Adds a gRPC service to be served from this endpoint.
   *
   * The {@link ServiceOpts} passed here need to describe the following properties:
   *
   *   - The 'service' name: the name of the gRPC service (as in the service definition proto file).
   *   - The service 'instance': the implementation of the service logic (must implement the generated
   *     gRPC service interface).
   *   - The gRPC/protobuf 'descriptor': The protoMetadata descriptor that describes the service, methods,
   *     and parameter types. It is usually found as the value 'protoMetadata' in the generated
   *     file '(service-name).ts'
   *
   *     The descriptor is generated by the protobuf compiler and needed by Restate to reflectively discover
   *     the service details, understand payload serialization, perform HTTP/JSON-to-gRPC transcoding, or
   *     to proxy the service.
   *
   * If you define multiple services in the same '.proto' file, you may have only one descriptor that
   * describes all services together. You can pass the same descriptor to multiple calls of '.bindService()'.
   *
   * If you don't find the gRPC/protobuf descriptor, make your you generated the gRPC/ProtoBuf code with
   * the option to generate the descriptor. For example, using the 'ts-proto' plugin, make sure you pass
   * the 'outputSchema=true' option. If you are using Restate's project templates, this should all be
   * pre-configured for you.
   *
   * @example
   * ```
   * endpoint.bindService({
   *   service: "MyService",
   *   instance: new myService.MyServiceImpl(),
   *   descriptor: myService.protoMetadata
   * })
   * ```
   *
   * @param serviceOpts The options describing the service to be bound. See above for a detailed description.
   * @returns An instance of this LambdaRestateServer
   */
  public bindService(serviceOpts: ServiceOpts): LambdaRestateServer {
    // Implementation note: This override if here mainly to change the return type to the more
    // concrete type LambdaRestateServer (from BaseRestateServer).
    super.bindService(serviceOpts);
    return this;
  }

  /**
   * Creates the invocation handler function to be called by AWS Lambda.
   *
   * The returned type of this function is `(event: APIGatewayProxyEvent) => Promise<APIGatewayProxyResult>`.
   * We use `any` types here to avoid a dependency on the `@types/aws-lambda` dependency for consumers of this API.
   *
   * @example
   * A typical AWS Lambda entry point would use this method the follwing way:
   * ```
   * import * as restate from "@restatedev/restate-sdk";
   *
   * export const handler = restate
   *   .createLambdaApiGatewayHandler()
   *   .bindService({
   *      service: "MyService",
   *      instance: new myService.MyServiceImpl(),
   *      descriptor: myService.protoMetadata,
   *    })
   *   .handle();
   * ```
   *
   * @returns The invocation handler function for to be called by AWS Lambda.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public handle(): (event: any) => Promise<any> {
    // return the handler and bind the current context to it, so that it can find the other methods in this class.
    return this.handleRequest.bind(this);
  }

  // --------------------------------------------------------------------------

  /**
   * This is the main request handling method, effectively a typed variant of `create()`.
   */
  private async handleRequest(
    event: APIGatewayProxyEvent
  ): Promise<APIGatewayProxyResult> {
    const pathSegments = event.path.split("/");

    // API Gateway can add a prefix to the path based on the name of the Lambda function and deployment stage
    // (e.g. /default)
    // So we only check the ending of the path on correctness.
    // Logic:
    // 1. Check whether there are at least three segments in the path and whether the third-last one is "invoke".
    // If that is the case, treat it as an invocation.
    // 2. See if the last one is "discover", answer with discovery.
    // 3. Else report "invalid path".
    if (
      pathSegments.length >= 3 &&
      pathSegments[pathSegments.length - 3] === "invoke"
    ) {
      const url = "/" + pathSegments.slice(-3).join("/");
      return await this.handleInvoke(url, event);
    } else if (pathSegments[pathSegments.length - 1] === "discover") {
      return this.handleDiscovery();
    } else {
      const msg =
        "Invalid path: path doesn't end in /invoke/SvcName/MethodName and also not in /discover: " +
        event.path;
      rlog.error(msg);
      rlog.trace();
      return this.toErrorResponse(500, msg);
    }
  }

  private async handleInvoke(
    url: string,
    event: APIGatewayProxyEvent
  ): Promise<APIGatewayProxyResult> {
    const method = this.methodByUrl(url);
    if (event.body == null) {
      const msg = "The incoming message body was null";
      rlog.error(msg);
      rlog.trace();
      return this.toErrorResponse(500, msg);
    }
    const connection = new LambdaConnection(event.body);
    if (method === undefined) {
      if (url.includes("?")) {
        const msg = `Invalid path: path URL seems to include query parameters: ${url}`;
        rlog.error(msg);
        rlog.trace();
        return this.toErrorResponse(500, msg);
      } else {
        const msg = `No service found for URL: ${url}`;
        rlog.error(msg);
        rlog.trace();
        return this.toErrorResponse(404, msg);
      }
    } else {
      new DurableExecutionStateMachine(
        connection,
        method,
        ProtocolMode.REQUEST_RESPONSE
      );
    }

    const result = await connection.getResult();

    return {
      headers: {
        "content-type": "application/restate",
      },
      statusCode: 200,
      isBase64Encoded: true,
      body: result.toString("base64"),
    };
  }

  private handleDiscovery(): APIGatewayProxyResult {
    // return discovery information
    rlog.info(
      "Answering discovery request. Registering these services: " +
        JSON.stringify(this.discovery.services)
    );
    return {
      headers: {
        "content-type": "application/proto",
      },
      statusCode: 200,
      isBase64Encoded: true,
      body: Buffer.from(
        ServiceDiscoveryResponse.encode(this.discovery).finish()
      ).toString("base64"),
    };
  }

  private toErrorResponse(code: number, message: string) {
    return {
      headers: {
        "content-type": "application/restate",
      },
      statusCode: code,
      isBase64Encoded: true,
      body: Buffer.from(JSON.stringify({ message: message })).toString(
        "base64"
      ),
    };
  }
}
