/*
 * Copyright (c) 2023 - Restate Software, Inc., Restate GmbH
 *
 * This file is part of the Restate SDK for Node.js/TypeScript,
 * which is released under the MIT license.
 *
 * You can find a copy of the license in file LICENSE in the root
 * directory of this repository or package, or at
 * https://github.com/restatedev/sdk-typescript/blob/main/LICENSE
 */

import { rlog } from "../utils/logger";
import {
  APIGatewayProxyEvent,
  APIGatewayProxyEventV2,
  APIGatewayProxyResult,
  APIGatewayProxyResultV2,
} from "aws-lambda";
import {
  ProtocolMode,
  ServiceDiscoveryResponse,
} from "../generated/proto/discovery";
import { BaseRestateServer, ServiceOpts } from "./base_restate_server";
import { LambdaConnection } from "../connection/lambda_connection";
import { InvocationBuilder } from "../invocation";
import { decodeLambdaBody } from "../io/decoder";
import { Message } from "../types/types";
import { StateMachine } from "../state_machine";
import { ensureError } from "../types/errors";

/**
 * Creates an Restate entrypoint for services deployed on AWS Lambda and invoked
 * through API Gateway.
 *
 * Register services on this entrypoint via {@link LambdaRestateServer.bindService } and
 * then create the Lambda invocation handler via {@link LambdaRestateServer.handle }.
 *
 * @example
 * A typical AWS Lambda entry point would look like this
 * ```
 * import * as restate from "@restatedev/restate-sdk";
 *
 * export const handler = restate
 *   .createLambdaApiGatewayHandler()
 *   .bindService({
 *      service: "MyService",
 *      instance: new myService.MyServiceImpl(),
 *      descriptor: myService.protoMetadata,
 *    })
 *   .handle();
 * ```
 */
export function createLambdaApiGatewayHandler(): LambdaRestateServer {
  return new LambdaRestateServer();
}

/**
 * Restate entrypoint implementation for services deployed on AWS Lambda.
 * This one decodes the requests, create the log event sequence that
 * drives the durable execution of the service invocations.
 */
export class LambdaRestateServer extends BaseRestateServer {
  constructor() {
    super(ProtocolMode.REQUEST_RESPONSE);
  }

  /**
   * Adds a gRPC service to be served from this endpoint.
   *
   * The {@link ServiceOpts} passed here need to describe the following properties:
   *
   *   - The 'service' name: the name of the gRPC service (as in the service definition proto file).
   *   - The service 'instance': the implementation of the service logic (must implement the generated
   *     gRPC service interface).
   *   - The gRPC/protobuf 'descriptor': The protoMetadata descriptor that describes the service, methods,
   *     and parameter types. It is usually found as the value 'protoMetadata' in the generated
   *     file '(service-name).ts'
   *
   *     The descriptor is generated by the protobuf compiler and needed by Restate to reflectively discover
   *     the service details, understand payload serialization, perform HTTP/JSON-to-gRPC transcoding, or
   *     to proxy the service.
   *
   * If you define multiple services in the same '.proto' file, you may have only one descriptor that
   * describes all services together. You can pass the same descriptor to multiple calls of '.bindService()'.
   *
   * If you don't find the gRPC/protobuf descriptor, make your you generated the gRPC/ProtoBuf code with
   * the option to generate the descriptor. For example, using the 'ts-proto' plugin, make sure you pass
   * the 'outputSchema=true' option. If you are using Restate's project templates, this should all be
   * pre-configured for you.
   *
   * @example
   * ```
   * endpoint.bindService({
   *   service: "MyService",
   *   instance: new myService.MyServiceImpl(),
   *   descriptor: myService.protoMetadata
   * })
   * ```
   *
   * @param serviceOpts The options describing the service to be bound. See above for a detailed description.
   * @returns An instance of this LambdaRestateServer
   */
  public bindService(serviceOpts: ServiceOpts): LambdaRestateServer {
    // Implementation note: This override if here mainly to change the return type to the more
    // concrete type LambdaRestateServer (from BaseRestateServer).
    super.bindService(serviceOpts);
    return this;
  }

  /**
   * Creates the invocation handler function to be called by AWS Lambda.
   *
   * The returned type of this function is `(event: APIGatewayProxyEvent | APIGatewayProxyEventV2) => Promise<APIGatewayProxyResult | APIGatewayProxyResultV2>`.
   * We use `any` types here to avoid a dependency on the `@types/aws-lambda` dependency for consumers of this API.
   *
   * @example
   * A typical AWS Lambda entry point would use this method the follwing way:
   * ```
   * import * as restate from "@restatedev/restate-sdk";
   *
   * export const handler = restate
   *   .createLambdaApiGatewayHandler()
   *   .bindService({
   *      service: "MyService",
   *      instance: new myService.MyServiceImpl(),
   *      descriptor: myService.protoMetadata,
   *    })
   *   .handle();
   * ```
   *
   * @returns The invocation handler function for to be called by AWS Lambda.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public handle(): (event: any) => Promise<any> {
    // return the handler and bind the current context to it, so that it can find the other methods in this class.
    return this.handleRequest.bind(this);
  }

  // --------------------------------------------------------------------------

  /**
   * This is the main request handling method, effectively a typed variant of `create()`.
   */
  private async handleRequest(
    event: APIGatewayProxyEvent | APIGatewayProxyEventV2
  ): Promise<APIGatewayProxyResult | APIGatewayProxyResultV2> {
    let path;
    if ("path" in event) {
      // V1
      path = event.path;
    } else {
      // V2
      path = event.rawPath;
    }
    const pathSegments = path.split("/");

    // API Gateway can add a prefix to the path based on the name of the Lambda function and deployment stage
    // (e.g. /default)
    // So we only check the ending of the path on correctness.
    // Logic:
    // 1. Check whether there are at least three segments in the path and whether the third-last one is "invoke".
    // If that is the case, treat it as an invocation.
    // 2. See if the last one is "discover", answer with discovery.
    // 3. Else report "invalid path".
    if (
      pathSegments.length >= 3 &&
      pathSegments[pathSegments.length - 3] === "invoke"
    ) {
      const url = "/" + pathSegments.slice(-3).join("/");
      return await this.handleInvoke(url, event);
    } else if (pathSegments[pathSegments.length - 1] === "discover") {
      return this.handleDiscovery();
    } else {
      const msg =
        "Invalid path: path doesn't end in /invoke/SvcName/MethodName and also not in /discover: " +
        path;
      rlog.error(msg);
      rlog.trace();
      return this.toErrorResponse(500, msg);
    }
  }

  private async handleInvoke(
    url: string,
    event: APIGatewayProxyEvent | APIGatewayProxyEventV2
  ): Promise<APIGatewayProxyResult | APIGatewayProxyResultV2> {
    try {
      const method = this.methodByUrl(url);
      if (event.body == null) {
        throw new Error("The incoming message body was null");
      }

      if (method === undefined) {
        if (url.includes("?")) {
          throw new Error(
            `Invalid path: path URL seems to include query parameters: ${url}`
          );
        } else {
          const msg = `No service found for URL: ${url}`;
          rlog.error(msg);
          return this.toErrorResponse(404, msg);
        }
      }

      // build the previous journal from the events
      let decodedEntries: Message[] | null = decodeLambdaBody(event.body);
      const journalBuilder = new InvocationBuilder(method);
      decodedEntries.forEach((e: Message) => journalBuilder.handleMessage(e));
      decodedEntries = null;

      // set up and invoke the state machine
      const connection = new LambdaConnection();
      const stateMachine = new StateMachine(
        connection,
        journalBuilder.build(),
        ProtocolMode.REQUEST_RESPONSE
      );
      await stateMachine.invoke();
      const result = await connection.getResult();

      return {
        headers: {
          "content-type": "application/restate",
        },
        statusCode: 200,
        isBase64Encoded: true,
        body: encodeResponse(result),
      };
    } catch (e) {
      const error = ensureError(e);
      rlog.error(error.message);
      rlog.error(error.stack);
      return this.toErrorResponse(500, error.message);
    }
  }

  private handleDiscovery(): APIGatewayProxyResult | APIGatewayProxyResultV2 {
    // return discovery information
    rlog.info(
      "Answering discovery request. Registering these services: " +
        JSON.stringify(this.discovery.services)
    );
    return {
      headers: {
        "content-type": "application/proto",
      },
      statusCode: 200,
      isBase64Encoded: true,
      body: encodeResponse(
        ServiceDiscoveryResponse.encode(this.discovery).finish()
      ),
    };
  }

  private toErrorResponse(code: number, message: string) {
    return {
      headers: {
        "content-type": "application/restate",
      },
      statusCode: code,
      isBase64Encoded: true,
      body: encodeResponse(Buffer.from(JSON.stringify({ message }))),
    };
  }
}

function encodeResponse(data: Uint8Array): string {
  const buffer = data instanceof Buffer ? data : Buffer.from(data);
  return buffer.toString("base64");
}
